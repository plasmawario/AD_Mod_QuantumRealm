import { DC } from "../constants";
import { Currency } from "../currency";
import { Tickspeed_Quantum } from "../tickspeed_quantum";

import { DimensionState } from "./dimensionTriple";

/***
 * Do additional logic when we buy a dimension
 */
function onBuyDimension(tier) {
  if (tier === 1) TutorialQuantum.turnOffEffect(TUTORIAL_QUANTUM_STATE.ELECTRON);
}

/***
 * This will buy a single quark generator
 * @param {number} tier The nth dimension to buy
 * @returns {boolean} whether or not the purchase was successful
 */
export function buySingleElectronGenerator(tier) {
  const dim = ElectronGenerator(tier);

  //cancel buying generator if we cannot afford it or if it is locked
  if (Currency.quarks1.lt(dim.cost) || !dim.isUnlocked) return false;

  //achievement handling, since it's not as nicely spaced out as the other ones
  if (tier === 1) QuantumAchievement(22).unlock();
  if (tier === 2) QuantumAchievement(38).unlock();
  if (tier === 3) QuantumAchievement(42).unlock();

  Currency.quarks1.subtract(dim.cost);

  //note that "amount" and "bought" are different values. This means we can have a multiplier
  //based on how many we actually bought, and not how many were generated by, say, a dimension

  dim.amount = dim.amount.plus(1);
  dim.bought += 1;

  //dim.cost = dim.nextCost(dim.bought);

  //challenge stuff  
  if (FusionChallenge(3).isRunning) {
    resetDownQuarkGenerator();
    resetUpQuarkGenerator();
  }

  onBuyDimension(tier);
  return true;
}

/***
 * This will reset your generators to their base amount that you have already bought
 */
export function resetElectronGenerator() {
  for (const dim of ElectronGenerators.all) dim.amount = new Decimal(dim.bought);
  //updateElectronGeneratorCosts();
}

/***
 * This will completely reset your generators to nothing
 */
export function fullResetElectronGenerator() {
  for (const dim of ElectronGenerators.all) {
    dim.cost = new Decimal(dim.baseCost);
    dim.amount = DC.D0;
    dim.bought = 0;
  }
}

/***
 * This will toggle the autobuyer settings of all your generators
 */
export function toggleAllElectronGenerators() {
  const areEnabled = Autobuyer.electronGenerator(1).isActive;
  for (let i = 1; i < 4; i++) {
    Autobuyer.electronGenerator(i).isActive = !areEnabled;
  }
}

/***
 * This will buy max your specified generator
 * @param {number} tier The nth dimension to buy max
 * @param {number} portionToSpend i dunno (Default: 1)
 * @returns {boolean} whether or not the purchase was successful
 */
export function buyMaxElectronGenerator(tier, bulk = Infinity) {

  /**
   * This block of code is the old algorithm taken from the time dimension logic. It appears to work
   * fine, but it breaks when we reach the post-fusion cost scaling, causing prices to jump to
   * absurd amounts, clearly not intentioned. It has been replaced with the logic below, which
   * is taken from the tickspeed buy max logic. It seems to work with our post-fusion cost scaling
   * when using buy max, though i am skeptical that it's a perfect replacement. For now, i'll
   * keep this block here just in case, but so far this logic replacement seems to work fine.
   */

  /*const canSpend = Currency.quarks1.value.times(portionToSpend);
  const dim = ElectronGenerator(tier);
  if (canSpend.lt(dim.cost) || !dim.isUnlocked) return false;
  
  const bulk = bulkBuyBinarySearch(canSpend, {
    costFunction: bought => dim.nextCost(bought),
    cumulative: true,
    firstCost: dim.cost,
  }, dim.bought);
  if (!bulk) return false;
  
  Currency.quarks1.subtract(bulk.purchasePrice);
  dim.amount = dim.amount.plus(bulk.quantity);
  dim.bought += bulk.quantity;
  dim.cost = dim.nextCost(dim.bought);*/

  const dim = ElectronGenerator(tier);
  if (!dim.isAffordable || !dim.isUnlocked) return false;

  const purchases = dim.costScale.getMaxBought(dim.bought, Currency.quarks1.value, 1, 1, bulk);
  if (purchases === null) {
      return;
  }
  Currency.quarks1.subtract(Decimal.pow10(purchases.logPrice));
  dim.bought += purchases.quantity;
  dim.amount = dim.amount.plus(purchases.quantity);

  //challenge stuff  
  if (FusionChallenge(3).isRunning) {
    resetDownQuarkGenerator();
    resetUpQuarkGenerator();
  }

  return true;
}

/***
 * This will buy max your all quark generators
 */
export function maxAllElectronGenerator() {

  // Try to buy single from the highest affordable new dimensions
  for (let i = 3; i > 0 && ElectronGenerator(i).bought === 0; i--) {
    buySingleElectronGenerator(i);
    //buySingleElectronGenerator(i, true);
  }

  // Buy everything costing less than 1% of initial electrons
  for (let i = 3; i > 0; i--) {
    buyMaxElectronGenerator(i);
    //buyMaxElectronGenerator(i, 0.01, true);
  }

  // Loop buying the cheapest dimension possible; explicit infinite loops make me nervous
  const unlockedDimensions = ElectronGenerators.all.filter(d => d.isUnlocked);
  
  //implement this check just in case the player tries to buy max all when they have
  //not unlocked electron-type generators yet
  if (unlockedDimensions.length == 0) return;

  for (let stop = 0; stop < 1000; stop++) {
    const cheapestDim = unlockedDimensions.reduce((a, b) => (b.cost.gte(a.cost) ? a : b));
    if (!buySingleElectronGenerator(cheapestDim.tier, true)) break;
  }
}

/***
 * This determine the multiplier of your quark generators
 * @returns {Decimal} the resulting multiplier
 */
export function electronGeneratorCommonMultiplier() {
  /*let mult = new Decimal(ShopPurchase.allDimPurchases.currentMult);
  return mult;*/

  let multi = DC.D5;

  //achievements make these stronger
  if (QuantumAchievement(46).isUnlocked) multi = multi.times(QuantumAchievements.power);

  return multi;
}

/***
 * This will simply update the costs for your quark generators
 */
/*export function updateElectronGeneratorCosts() {
  for (let i = 1; i <= 3; i++) {
    const dim = ElectronGenerator(i);
    dim.cost = dim.nextCost(dim.bought);
  }
}*/

/***
 * This is the class that contains information related to quark generators, along with a
 * constructor and functions
 */
class ElectronGeneratorState extends DimensionState {
  constructor(tier) {
    super(() => player.dimensions.electrons, tier);
    const BASE_COSTS = [null, DC.E30, DC.E80, DC.E150];      //these are apparently instead set in player
    this._baseCost = BASE_COSTS[tier];
    const COST_MULTS = [null, 5, 1e5, 1e10];
    this._costMultiplier = COST_MULTS[tier];
    const FC6_COST_MULTS = [null, 6, 2e5, 2e10];
    this._FC6_costMultiplier = FC6_COST_MULTS[tier];
    const POSTINF_COST_MULTIPLIERS = [null, 10, 10, 10];
    this._postinfCostMultiplier = POSTINF_COST_MULTIPLIERS[tier];
  }

  /** @returns {Decimal} */
  get cost() {
    return this.costScale.calculateCost(Math.floor(this.bought));
    //return this.data.cost;
  }

  /** @param {Decimal} value */
  set cost(value) { this.data.cost = value; }

  get costScale() {
    return new ExponentialCostScaling({
      baseCost: this._baseCost,
      baseIncrease: FusionChallenge(6).isRunning ? this._FC6_costMultiplier : this._costMultiplier,
      costScale: Player.postFusionCostScaleMulti,
      scalingCostThreshold: Number.MAX_VALUE
    });
  }

  /***
  * This will calculate the cost of your next quark generator after buying one
  * @param {number} bought how many generators that have been bought
  * @returns {Decimal} the new calculated cost
  */
  /*nextCost(bought) {
    let base = this.costMultiplier;
    const exponent = bought;
    const cost = Decimal.pow(base, exponent).times(this.baseCost);

    return cost;
  }*/

  /***
  * This will get whether or not we have reached the requirement for unlocking an electron generator
  * and make it visible
  * @returns {boolean} whether the requirement was reached
  */
    get requirementReached() {
      const tier = this._tier;

      //challenge
      if (FusionChallenge(8).isRunning) return;
  
      return (tier === 1) || (PlayerProgress.matterUnlocked() && 
                              (tier === 2 && WebNode.muon.canBeApplied) ||
                              (tier === 3 && WebNode.tau.canBeApplied));
      //return ElectronGenerator(tier).cost.equals(Currency.electrons.value);
    }

  /***
  * This will check to see if the electron generator is unlocked and visible or not, and
  * make it purchaseable
  * @returns {boolean} whether the generator is unlocked and visible
  */
  get isUnlocked() {
    const tier = this._tier;

    //this can only be unlocked after the requirement has been reached. If so,
    //unlock the generator if this is a tier 1, 
    //or if the total amount of quarks made is more than the cost of generator,
    //or you already own a generator of this tier
    return this.requirementReached &&
      (
      this.isAvailableForPurchase ||
      ElectronGenerator(tier).amount.gte(1)
    );
  }

  /***
  * This will check to see if we can buy this quark generator
  * @returns {boolean} whether or not the purchase was successful
  */
  get isAvailableForPurchase() {
    return this.isAffordable;
  }

  /***
  * This will check if we can afford to buy this quark generator
  * @returns {boolean} whether or not the purchase was successful
  */
  get isAffordable() {
    return Currency.quarks1.gte(this.cost);
  }

  /***
  * This will calculate the total multiplier for a generator
  * @returns {Decimal} the new calculated multiplier
  */
  get multiplier() {
    const tier = this._tier;
    const dim = ElectronGenerator(tier);
    let mult = dim.baseMultiplier;

    //other multiplier boosts
    mult = mult.timesEffectsOf(
      QuantumAchievement(27),
      QuantumAchievement(31),
      QuantumAchievement(45)
    );

    //apply multiplier of the 2nd quark upgrade
    //mult = mult.times(Decimal.pow(FermionUpgrade(2).config.effects.QuarkGeneratorMulti(), FermionUpgrade(2).boughtAmount)).clampMin(1);
    
    //apply multiplier based on how many generators were bought (excluding the ones generated by higher-tier generators)
    mult = mult.times(Decimal.pow(ElectronGenerators.generatorPurchaseMultiplier, dim.bought)).clampMin(1);
    if (WebNode.chargeAmp.canBeApplied) mult = mult.times(Currency.electricCharge.value.pow(ElectronGenerators.powerConversionRate).max(1).pow(0.015));
    mult = mult.times(WebNode.electronBoostFusions.effectOrDefault(1));

    /*const upgradeBought = dim.bought;
    mult = mult.times(Decimal.mul(dim.upgradedMultiplier, upgradeBought));*/

    return mult;
  }

  /***
  * This will calculate the production of quarks your generators are producing per second
  * @returns {Decimal} the production of quarks per second
  */
  get productionPerSecond() {
    let production = this.amount.times(this.multiplier);

    //let tickspeed affect our quark generators
    production = production.times(Tickspeed_Quantum.perSecond);

    return production;
  }

  /***
  * This will calculate the production of electric charge your generators are producing per second
  * @returns {Decimal} the production of quarks per second
  */
  get productionChargePerSecond() {
    let production = this.amount.times(this.multiplier);

    //let tickspeed affect our quark generators
    production = production.times(Tickspeed_Quantum.perSecond);

    production = production.pow(ElectronGenerators.productionPower).times(ElectronGenerators.powerConversionRate);

    return production;
  }

  /***
  * This will calculate the rate of change of your quark production
  * @returns {Decimal} the rate of change
  */
  get rateOfChange() {
    const tier = this._tier;

    if (tier == 3){
      return DC.D0;
    }

    const toGain = ElectronGenerator(tier + 1).productionPerSecond;
    const current = Decimal.max(this.amount, 1);
    return toGain.times(10).dividedBy(current).times(getGameSpeedupForDisplay());

    //actually we're just gonna output the quark production per second of each generator
    //return ElectronGenerator(tier).productionPerSecond.times(getGameSpeedupForDisplay());
    
  }

  /***
  * This will determine if a particular generator is currently producing or not
  * @returns {Decimal} i dunno
  */
  get isProducing() {
    const tier = this.tier;

    return this.amount.gt(0);
  }

  /***
  * This will get the base cost of your generator
  * @returns {boolean} the base cost of your generator
  */
  get baseCost() {
    return this._baseCost;
  }

  /***
  * This will get the cost multiplier of your generator
  * @returns {boolean} the cost multiplier of your generator
  */
  get costMultiplier() {
    return this._costMultiplier;
  }

  /***
  * This will return the base multiplier of your quark generators
  * @returns {Decimal} the base multiplier of your quark generators
  */
  get baseMultiplier() {
    return GameCache.electronGeneratorCommonMultiplier.value;
  }

  get shortDisplayName() {
    const tier = this._tier;
    let genName = "";
    switch (tier){
        case 1:
            genName = "Electron";
            break;
        case 2:
            genName = "Muon";
            break;
        case 3:
            genName = "Tau";
            break;
    }

    return genName;
  }

  /***
  * This will attempt to unlock a quark generator
  */
  /*tryUnlock() {
    if (this.isUnlocked) return;
    TimeStudy.timeDimension(this._tier).purchase();
  }*/
}

/**
 * @function
 * @param {number} tier
 * @return {ElectronGeneratorState}
 */
export const ElectronGenerator = ElectronGeneratorState.createAccessor();

export const ElectronGenerators = {
  /**
   * @type {ElectronGeneratorState[]}
   */
  all: ElectronGenerator.index.compact(),

  get generatorPurchaseMultiplier() {
    //const tier = this.tier;

    let mult = FusionUpgrade2(9).effectOrDefault(DC.D1_3);

    return mult;
  },

  canBuy() {
    return true;
  },

  tick(diff) {
    //defines which generator produces other generators
    for (let tier = 3; tier > 1; tier--) {
        ElectronGenerator(tier).produceDimensions(ElectronGenerator(tier - 1), diff / 10);
    }

    //defines which generator produces currency
    ElectronGenerator(1).produceCurrency(Currency.electrons, diff);

    //generate electric charge once we have the web node for it
    if (WebNode.electricCharge.canBeApplied) 
        ElectronGenerator(1).produceCurrencyModified(Currency.electricCharge, diff, ElectronGenerators.productionPower);
  },

  get productionPower() {
    const power = Effects.max(
      0.25,
      FusionUpgrade2(5)
    );

    return power;
  },

  /**
   * calculates power effect for electric charge on quark generators
   */
  get powerConversionRate() {
    const downBoostMult = WebNode.downBoostCharge.canBeApplied ? Math.pow(player.downBoosts, 0.5) + 1 : 1;

    const multiplier = downBoostMult;

    return multiplier;
  }
};



/*export function tryUnlockTimeDimensions() {
  if (ElectronGenerator(8).isUnlocked) return;
  for (let tier = 5; tier <= 8; ++tier) {
    if (ElectronGenerator(tier).isUnlocked) continue;
    ElectronGenerator(tier).tryUnlock();
  }
}*/
